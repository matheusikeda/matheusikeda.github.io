---
layout: post
title: Funções de alta ordem
---

### Funções de alta ordem
Sucintamente, são funções que tem como parâmetros outras funções, podendo ou não retornar uma outra função. Uma função deste tipo muito conhecida e usada que ilustra seu funcionamento é a zipWith.
Código:
{% highlight haskell %}zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith _ [] _ = [] zipWith _ _ [] = [] zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys{% endhighlight %}  
Na declaração do tipo, observa-se que a mesma recebe como parâmetros uma função, que será usada no decorrer do código. Outros exemplos como map e filter seguem a mesma linha.
### Função fold
O foco deste post são as funções foldl e foldr. Segue abaixo as declarações respectivamente.
{% highlight haskell %}foldl :: (a -> b -> a) -> a -> [b] -> a foldl f v [] = v foldl f v (x:xs) = foldl f (f x v) xs foldr :: (a -> b -> b) -> b -> [a] -> b foldl f v [] = v foldl f v (x:xs) = f x (foldr f v xs){% endhighlight %}  
 Uma "fold" percorre uma lista aplicando uma determinada função sobre os elementos e retorna um único valor acumulado resultado de tal aplicação. Basicamente, a diferença entre elas é de que lado da lista a função inicia-se, sendo a foldl pela esquerda e a foldr pela direita.
 A foldl recebe uma função binária, uma valor inicial e uma lista, retornando um valor resultante. A exemplo, a função sum pode ser declarada usando a mesma
 {% highlight haskell %}sum :: (Num a) => [a] -> a sum = foldl (+) 0 {% endhighlight %}  
 Rastreio de código


 
 
 
 
 

